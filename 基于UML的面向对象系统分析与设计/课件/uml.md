### 软件工程概述

#### 软件

1. 软件的定义：软件是计算机程序以及运行计算机程序可能需要的相关数据和文档；软件=程序+数据+文档
2. 软件的本质
   软件是客观世界中联系问题空间与解空间的具体描述，它实质上是客观事物的一种反映，是知识的“提炼”和“固化”。
   软件 = 知识 + 程序 + 数据 + 文档
3. 通用软件：软件开发组织开发、面向市场、独立运行系统，有时也被称为套装软件。举例：操作系统、数据库系统、微信、淘宝等
4. 定制软件：某个特定客户委托、合同约束。举例：企业ERP系统、卫星控制系统、银行APP等
5. 软件危机具体表现：软件开发的成本和进度难以准确估计，延迟交付甚至取消项目的现象屡见不鲜
   软件存在着错误多、性能低、不可靠、不安全等质量问题
   软件维护十分困难，很难适应不断变化的用户需求和使用环境
6. 软件的特性：**软件是不可见的**
   ·它是一种逻辑实体，不具有物理的形体特征
   ·定义“需要做什么”成为软件开发的根本问题
   **建模技术：软件可视化的方法**
   ·结构化技术：数据流图、状态转换图、实体关系图
   ·面向对象技术：统一建模语言UML

> 软件是复杂的：大量组合状态、丰富的结构和互相依赖性
>
> 抽象和分解：降低复杂性的有效方法

​	**软件是不断演化的**
​	·所有成功的软件都会发生变更
​	·人们总是认为软件是容易修改的，但忽视了修改所带来的副作用（01.软件工	程概述.pptx P19 软件的失效率曲线）（更多特性：p20）

7. 如何评价软件质量：

   ![image-20221210100531253](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20221210100531253.png)

#### 软件工程

1. 软件工程的特征

> 软件工程是一个建模的活动
>
> 软件工程是一个问题求解的活动
>
> 软件工程是一个知识获取的活动
>
> 软件工程是一个协调与控制开发过程的活动：团队分工协作、软件过程管理、软件配置管理、软件项目管理

2. 软件工程的发展

> 软件工程的诞生：1968年，提出“软件工程”和“软件危机”的术语
>
> 一本经典的著作“人月神话”
>
> 控制机器（1956~1967）
>
> 控制过程（1968~1982）
>
> 控制复杂性（1983~1995）
>
> 1996~现在

3. 软件工程的目标

> 在规定的时间和规定的预算内开发出高质量的软件
> 提高软件的质量与生产率，最终实现软件的工业化生产

4. 软件工程的素养

> **过程**：支持软件生命周期的所有活动
> **方法**：为软件开发过程提供“如何做”的技术
> **工具**：为软件开发方法提供自动的或半自动的软件支撑环境

5. 什么是软件过程

> 软件过程是指开发软件产品的一组活动及其结果。
>
> ![image-20221210101410656](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20221210101410656.png)

6. 什么是软件模型过程

> 软件过程模型是软件过程的抽象表示
>
> 常见的软件过程模型
> 瀑布模型
> 快速原型模型
> 增量模型
> 形式化方法模型

7. 什么是软件工程方法

> 软件工程方法是为开发软件提供技术上的解决方法，通常包括某种语言或图形的模型表示方法、良好的设计实践以及质量保证标准等
>
> **传统的结构化方法**
> 以算法作为基本构造单元，强调自顶向下的功能分解，将功能和数据进行了一定程度的分离
> **面向对象方法**
> 从现实世界中客观存在的事物（即对象）出发，运用抽象、分类、继承、聚合、封装等方式来构造软件系统。
>
> ![image-20221210101513498](C:\Users\4334\AppData\Roaming\Typora\typora-user-images\image-20221210101513498.png)

8. 什么是软件工程工具

> 软件工程工具为软件工程方法提供了自动的或半自动的软件支撑环境，辅助软件开发任务的完成
>
> CASE（见ppt第36页）

9. 软件工程面临的一些挑战

> 遗留系统的问题
> 遗留系统是指那些过时或存在问题的计算机系统，通常是许多年以前开发的
> 挑战：既要以合理的成本维护和更新系统，又要能够继承系统中重要的商业信息和服务
>
> 异构系统的问题
> 网络环境下包含不同的硬件平台和软件系统
> 挑战：需要提出新的开发技术，能够使所开发的软件系统运行在不同的硬件平台和系统环境下
>
> 高可信软件开发的要求
> 软件的重要作用要求正确性、可靠性、安全性等可信性质
> 挑战：如何在软件的开发和运行中保证其具有高可信的性质
>
> 开源软件的模式
> 开源软件是将系统程序源代码开放，允许用户自行修改
> 挑战：开发某种技术使软件的局部修改更加容易和可靠



### 面向对象基础

#### 从结构化到面向对象

1. 结构化

> 通过流程图（结构化建模）可以更清楚表达设计思想
> 针对过程的抽象
> ·过程（函数）是系统的核心，通过过程实现系统功能
> ·数据是静态的，由过程来控制对数据的访问

2. 对象方法

> 通过UML类图（面向对象建模）可以更清楚表达设计思想，并为代码实现提供框架
> 针对数据的抽象：类
> ·类拥有自己的数据和行为，能够完成自身的工作职责
> ·过程是类的组成部分，为类提供行为
> ·通过类的对象之间的**协作**完成系统功能

3. 面向对象技术的思考

> 对象思维具有更大的灵活性，更好的模块化，可以进行更大规模的设计
> 面向对象设计和开发的难度更大，面临着**对象识别、职责分配、多态抽象**等一系列问题
> ·学习更多知识和技术，并掌握一系列面向对象的设计原则和模式
> ·图形化工具（UML）有助于表达和交流设计思想，并简化实现的过程

4. 结构化VS面向对象（具体区别见ppt）

> ·结构化思维用过程刻画数据间关系
> ·对象思维直接用类表达数据间关系
> ·结构化中，数据是死的，全部依赖算法操作
> ·对象思维中，数据是活的，“她”知道自己的信息（属性），并能完成自己的工作（操作）
> ·结构化思维更像是一个人在解决所有问题
> ·对象思维更像是一个团队的分工协作

#### 面向对象技术

1. 面向对象技术

> 是一种看待软件系统的观点
> 是一种系统分析和设计的思想
> 是一种编程方法
> 是一组设计原则和模式

> 面向对象技术是一系列指导软件构造的原则（如抽象、封装、多态等），并通过语言、数据库和其它工具来支持这些原则
> ·从本质上讲，对象技术对一系列相关原则的应用
> ·面向对象技术 = 类+对象+抽象+封装+继承+多态+消息…

2. 面向对象技术优势

> 沟通：顺应人类思维习惯，让软件开发人员在解空间中直接模拟问题空间中的对象及其行为
>
> 稳定：较小的需求变化不会导致系统结构大的改变
> 当需求变化时……用较稳定的把不稳定的包起来
>
> 复用
> ·代码重用：类库、框架等重用机制
> ·能提高质量，减少由于编写新代码而产生的成本
> ·通过继承、关联、封装等手段

#### 对象和类

1. 对象

> 对象（Object）是一个实体、一件事、一个名词，可以获得的某种东西，可以想象成有自己标识的任何事物
>
> 物理实体、概念实体、软件实体

2. 对象的正式定义

> 对象是一个实体，这个实体：
> **具有明确定义的边界和标识**
> ·边界意味着对象是一个封装体，通过封装来与其它对象分隔
> ·标识则表明每一个对象都是唯一的
> **对象封装了状态和行为**
> ·对象的状态通过对象的属性（attribute）和关系（relationship）来表达
> ·对象的行为通过对象的操作（operation）、方法（method）和状态机（state machine）来表达

3. 在UML中表示对象

> 在UML中，对象用矩形框来表示，对象的名字写在矩形框内部，并加上下划线来表示

4. 类

> 类就是一系列对象的抽象描述，这些对象共享相同的属性、操作、关系和语义
> ·一个具体的对象是该类的一个实例
> 类是一种抽象
> ·将相似的实体抽象成相同的概念
> ·抽象过程强调相关特征而忽略其它的特征

5. uml中的类

> 在UML中，采用矩形框表示类，可以将矩形框划分为三个区域，分别表示类名、属性和操作
>
> **属性**(attribute)是类的特征或特性
> ·属性的值是某一特定对象的属性值
> ·在类中属性名必须是唯一的
> ·每一个类的实例都有为这个类定义的所有属性的值
>
> **操作**(operation)访问或修改对象的属性值
> ·对象的行为是由为此对象定义的一系列操作决定的
> ·一个类可能同时存在多个实例，也可能在某一时刻没有实例
> ·一个类的所有实例都可以使用在这个类中定义的操作

#### 面向对象技术相关原则

1. 面向对象技术基本原则

> 抽象、封装、分解、泛化、多态、分层、复用、...
>
> （ppt第43页
>
> 继承（ppt第53页）：单一继承（一个类继承另一个类）、多重继承（一个类继承另外多个类）

2. 启用复用原则

> 系统开发各个阶段都可能涉及到复用
> ·从最底层的代码复用，到设计复用、架构复用，再到需求复用，甚至于延伸到特定业务领域的复用
> 复用原则要求设计者不仅针对当前的业务需求开展设计，还需要考虑业务的通用性和可扩展性等问题，从而设计抽象层次高、复用粒度大的组件

#### 上升到面向对象

1. 用对象观点认识事物

> A.这里面有什么事物？类和对象
> B.每个事物看上去是什么样的？类的属性
> C.每个事物能做点什么？类的操作
> D.这些事物之间有什么关系？类之间的关联
> E.这些事物是怎么成事的？类之间的交互(用例实现)
>
> E：·抽象事物的属性和能力就是具体事物的属性和能力；具体事物除了有抽象事物的属性和能力外，还可以有自己特殊的属性和能力；
>
> ·事物分工协作，互通信息，共同完成整体的目标
>
> ·面向对象的分析和设计的核心

### 可视化建模基础

#### 可视化建模基础

1. 建模的目的

> 建模的根本目的是为了更好地理解待开发的系统（分而治之）
> ·模型有助于按照所需的样式可视化(Visualize)目标系统
> ·模型能够描述(Specify)系统的结构和行为
> ·模型提供构造(Construct)系统的模板
> ·模型可以文档化(Document)设计决策

2. 建模的基本原则

> 建模过程需要遵循的原则
> ·选择合适的模型：所创建的模型对解决方案的形成具有重要的影响
> ·模型具有不同的精确程度：面向不同的用户提供不同抽象层次的模型
> ·好的模型是与现实相联系的：简化不能掩盖掉任何重要的细节
> ·单一的模型是不够的：需要从多个视角创建不同的模型

#### 统一建模语言

1. UML

> 不是一种程序设计语言，而是一种可视化的建模语言(用于分析设计)
> 不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种模型表示的标准
> 不是过程，也不是方法，但允许任何一种过程和方法使用它

> 是对象管理组织（OMG）制定的一个通用的、可视化的建模语言标准，可以用来可视化（visualize） 、描述（specify）、构造（construct）和文档化（document）软件密集型系统的各种工件（artifacts，又译制品） 

2. 选择UML和不选择UML原因：ppt12
3. UML的统一

> 统一了什么：
>
> 开发生命周期
>
> 应用领域
>
> 实现语言和平台
>
> 开发过程

#### UML2概念模型

1. uml概念模型

> 构造块：基本UML建模元素
>
> 通用机制：应用于构造块的通用方法
>
> 架构：组织UML视图

2. 构造块（详细见ppt第21页开始）

> 事物(things)
> ·结构、行为、分组、注释
> 关系(relationships)
> ·依赖、关联、泛化、实现
> 图(diagram)
> ·静态(7种)：类图、对象图、构件图、部署图、**包图、组合结构图、外廓图**
> ·动态(7种)：顺序图、通信图、**时间图、交互概览图**、活动图、状态机图、用例图

3. 通用机制

> 规格说明(Specifications)
> ·文本维度的模型描述
> 修饰(Adornments)
> ·描述建模元素的细节信息
> 通用划分(Common Divisions)
> ·建模时对事物的划分方法
> 扩展机制(Extensibility Mechanisms)
> ·用于扩展UML建模元素
>
> 外廓（第32页）

4. 架构

> 4+1视图
>
> 用例视图：功能性需求；所有其他视图都是从用例视图派生而来，该视图把系统的基本需求捕获为用例并提供构造其他视图的基础。
>
> 逻辑视图：软件结构；作为类和对象的集合，重点是展示对象和类是如何组成系统、实现所需系统行为。
>
> 进程视图：性能、可扩展性、吞吐量；建模系统中的可执行线程和进程。其实，它是逻辑视图面向进程的变体，包含所有相同的工件。
>
> 实现视图：系统组装和配置管理；对组成系统的物理代码、文件和组件进行建模。
>
> 部署视图：拓扑、分布、移交、安装等；目标是把组件物理地部署到一组物理的、可计算节点上。

#### 应用UML2建模

